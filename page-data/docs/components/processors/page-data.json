{
    "componentChunkName": "component---node-modules-rocketseat-gatsby-theme-docs-core-src-templates-docs-query-js",
    "path": "/docs/components/processors",
    "result": {"data":{"mdx":{"id":"8739fe79-2cb5-508c-aa6e-d32231fe76a3","excerpt":"Processors are used in several stages of an OpenTelemetry collector pipeline. They are used to pre-process the data being passed in the pipeline. In a processorâ€¦","fields":{"slug":"/docs/components/processors/"},"frontmatter":{"title":"Processors","description":"Processors pre-process the data collected by the receivers before they are exported by exporters. Processors can modify, batch or\nfilter the data flowing through the pipeline.\n","image":null,"disableTableOfContents":null},"body":"var _excluded = [\"components\"];\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar _frontmatter = {\n  \"title\": \"Processors\",\n  \"description\": \"Processors pre-process the data collected by the receivers before they are exported by exporters. Processors can modify, batch or\\nfilter the data flowing through the pipeline.\\n\",\n  \"path\": \"/docs/components/processors\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Processors are used in several stages of an OpenTelemetry collector pipeline. They are used to pre-process the data being passed in the pipeline. In a processor the data can be modified, batched, filtered or sampled. The\\nADOT collector supports a selected list of processors.\"), mdx(SectionSeparator, {\n    mdxType: \"SectionSeparator\"\n  }), mdx(\"h2\", {\n    \"id\": \"processors-supported-by-adot-collector\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#processors-supported-by-adot-collector\",\n    \"aria-label\": \"processors supported by adot collector permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Processors supported by ADOT collector\"), mdx(\"p\", null, \"The ADOT collector supports the following processors:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/processor/attributesprocessor#attributes-processor\"\n  }, \"Attributes processor\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/open-telemetry/opentelemetry-collector/tree/main/processor/batchprocessor#batch-processor\"\n  }, \"Batch processor\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/processor/deltatorateprocessor#delta-to-rate-processor\"\n  }, \"Delta to Rate processor\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/processor/filterprocessor#filter-processor\"\n  }, \"Filter processor\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/main/processor/groupbytraceprocessor/README.md\"\n  }, \"Group by Trace processor\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/open-telemetry/opentelemetry-collector/tree/main/processor/memorylimiterprocessor#memory-limiter-processor\"\n  }, \"Memory Limiter processor\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/processor/metricsgenerationprocessor#metrics-generation-processor\"\n  }, \"Metrics Generation processor\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/processor/metricstransformprocessor#metrics-transform-processor\"\n  }, \"Metrics Transform processor\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/processor/probabilisticsamplerprocessor#probabilistic-sampling-processor\"\n  }, \"Probabilistic Sampling processor\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/processor/resourcedetectionprocessor#resource-detection-processor\"\n  }, \"Resource Detection processor\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/processor/resourceprocessor#resource-processor\"\n  }, \"Resource processor\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/processor/spanprocessor#span-processor\"\n  }, \"Span processor\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/processor/tailsamplingprocessor/README.md\"\n  }, \"Tail Sampling processor\"))), mdx(\"h2\", {\n    \"id\": \"notes-on-group-by-trace-and-tail-sampling-processors\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#notes-on-group-by-trace-and-tail-sampling-processors\",\n    \"aria-label\": \"notes on group by trace and tail sampling processors permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Notes on Group by Trace and Tail Sampling processors\"), mdx(\"p\", null, \"In order to achieve the desired results when using the Tail Sampling and Group by Trace processors, \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"do not use a Batch processor before these components in a pipeline\"), \". Using a Batch processor before these components might separate spans belonging to a same trace. It is important to pay attention to this detail because these components will try to group all the spans belonging to a trace. In the case of the Tail Sampling processor this will allow for a sampling decision to affect all spans of a trace, creating a full picture of the trace in case it is sampled. A Batch processor immediately after these components does not cause any problems and is recommended to properly pre-process data for subsequent exporters.\"), mdx(\"p\", null, \"Also, you need to make sure that all the spans for a trace are processed in the same collector instances. This is specially important for a collector running in gateway mode.\"), mdx(\"p\", null, \"Besides that, you have to tune the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"wait_duration\"), \" parameter of the Group by Trace processor and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"decision_wait\"), \" parameter of the Tail Sampling processor to be greater than or equal to the maximum expected latency of a trace in your system. Also, be sure to include a grace period for network latency between an application and collector. Again, this will guarantee that spans of a same trace are processed in the same batch.\"), mdx(\"p\", null, \"Finally to really limit the number of traces that should be kept in memory, we recommend that you use the Group by Trace processor before the Tail Sampling processor. The reason why is because the Group by Trace processor implements a limit for the number of traces to be kept in memory while this is not fully implemented in the Tail Sampling processor.\"), mdx(\"p\", null, \"The Group by Trace processor will drop the oldest trace in case the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"num_traces\"), \" limit is exceeded. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"wait_duration\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"num_traces\"), \" should be scaled to consider the expected traffic in the monitored applications.\"), mdx(\"h3\", {\n    \"id\": \"examples\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#examples\",\n    \"aria-label\": \"examples permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Examples\"), mdx(\"p\", null, \"If the maximum expected latency for a request in your application is 10s and the maximum traffic in number of requests per second that your application can have is 1000 requests per second, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"wait_duration\"), \" should be set to 10s and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"num_traces\"), \" should be set to at least 10000 (10 * 1000 requests per second). It is highly recommended that you monitor the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"otelcol_processor_groupbytrace_traces_evicted\"), \" metric from the collector \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://opentelemetry.io/docs/collector/configuration/#service\"\n  }, \"self telemetry\"), \". If the value in the metric is greater than zero, that means that the collector is receiving more traffic than it can handle and you should increase the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"num_traces\"), \" accordingly.\"), mdx(\"p\", null, \"Example from the description above:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-yaml\"\n  }, \"processors:\\n  groupbytrace:\\n    wait_duration: 10s\\n    num_traces: 20000 # Double the max expected traffic (2 * 10 * 1000 requests per second)\\n  tail_sampling:\\n    decision_wait: 1s # This value should be smaller than wait_duration\\n    policies:\\n      - ..... # Applicable policies\\n  batch/tracesampling:\\n    timeout: 0s # No need to wait more since this will happen in previous processors\\n    send_batch_max_size: 8196 # This will still allow us to limit the size of the batches sent to subsequent exporters\\n\\nservice:\\n  pipelines:\\n    traces/tailsampling:\\n      receivers: [otlp]\\n      processors: [groupbytrace, tail_sampling, batch/tracesampling]\\n      exporters: [awsxray]\\n\\n\")), mdx(\"p\", null, \"The Tail Sampling processor has the functionality to combine sampling policies. For example, to sample traces from a specific path in case of errors you could use the following configuration:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-yaml\"\n  }, \"processors:\\n  tail_sampling:\\n    decision_wait: 1s\\n    policies:\\n      - name: and-policy\\n        type: and\\n        and:\\n          and_sub_policy:\\n            - name: path-policy\\n              type: string_attribute\\n              string_attribute:\\n                key: http.url\\n                values: [\\\"\\\\/users\\\"]\\n                enabled_regex_matching: true\\n            - name: error-policy\\n              type: status_code\\n              status_code:\\n                status_codes: [\\\"ERROR\\\", \\\"UNSET\\\"]\\n\")), mdx(\"p\", null, \"In the next example we will sample 20% of the spans that present an error:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-yaml\"\n  }, \"processors:\\n  tail_sampling:\\n    decision_wait: 1s\\n    policies:\\n      - name: and-policy\\n        type: and\\n        and:\\n          and_sub_policy:\\n            - name: error-policy\\n              type: status_code\\n              status_code:\\n                status_codes: [\\\"ERROR\\\", \\\"UNSET\\\"]\\n            - name: probabilistic-policy\\n              type: probabilistic\\n              probabilistic:\\n                sampling_percentage: 20\\n\")), mdx(\"p\", null, \"To see the full set of policy options available to the tail sampling processor please refer to it's \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/processor/tailsamplingprocessor/README.md\"\n  }, \"README\"), \".\"));\n}\n;\nMDXContent.isMDXComponent = true;","headings":[{"depth":2,"value":"Processors supported by ADOT collector"},{"depth":2,"value":"Notes on Group by Trace and Tail Sampling processors"},{"depth":3,"value":"Examples"}]}},"pageContext":{"slug":"/docs/components/processors/","repositoryEditUrl":"https://github.com/rocketseat/gatsby-themes/tree/main/examples/gatsby-theme-docs/src/docs/components/processors.mdx","repositoryProvider":"GitHub"}},
    "staticQueryHashes": ["2501019404","973074209"]}